# binance 资产证明介绍


Chaineye rust binance por 教程，供想要学习的小伙伴学习。

推特：@seek_web3

Chainey 社群： 官网 chaineye.info | Chaineye Rust 教程 | 微信: LGZAXE, 加微信之后拉各社群 

所有代码和教程开源在github: https://github.com/0xchaineye/chaineye-binance-por

------------------------------------------------------------------------------------------------------------------------------------------------------------------

## 1. 什么是储备证明 (PoR)

当交易所说储备证明时，我们特指交易所为用户保管的那些资产。这意味着我们正在出示证据和证据，证明交易所的资金能够 1:1 覆盖我们所有用户的资产，以及一些储备金。

当用户存入一枚比特币时，交易所的储备金至少会增加一枚比特币，以确保客户资金得到充分支持。重要的是要注意，这不包括交易所的公司持股，这些持股保存在一个完全独立的分类账中。

这实际上意味着交易所以 1:1 的比例持有所有用户资产（以及一些储备金），交易所的资本结构中的债务为零，并且交易所确保我们有一个应急基金（SAFU 基金）以应对极端情况.


## 2. 什么是默克尔树

Merkle Tree 是一种加密工具，可以将大量数据整合到单个哈希中。这个称为 Merkle Root 的单一散列充当“汇总”所有输入数据的加密印章。此外，默克尔树使用户能够验证包含在一组特定“密封”数据中的特定内容。我们在储备证明评估期间使用 Merkle Trees 的这些属性来验证个人用户帐户是否包含在审计员检查的负债报告中。

[![binance-1](https://github.com/0xchaineye/chaineye-binance-por/blob/main/images/binance-1.png)](https://github.com/0xchaineye/chaineye-binance-por/)

### 2.1.哈希函数

为了简洁地对输入进行编码，Merkle 树依赖于哈希函数的使用。简而言之，哈希是从可变大小的输入生成固定大小的输出的过程。换句话说，当任意长度的输入通过算法进行哈希处理时，都会产生一个加密的定长输出。

只要输入保持不变，输出也将保持不变。这意味着我们可以获取大量交易数据并将其散列为可管理的输出。如果输入中的任何信息发生变化，输出将完全不同。

例如，我们可以将 100 本书的内容输入到 SHA-256 哈希函数中。然后它会提供类似这样的输出：

801a9be154c78caa032a37b4a4f0747f1e1addb397b64fa8581d749d704c12ea

如果我们随后更改输入的单个字符（那 100 本书），哈希将完全不同，如下所示：

abc5d230121d93a93a25bf7cf54ab71e8617114ccb57385a87ff12872bfda410

这是散列函数的一个重要属性，因为它可以轻松验证数据的准确性。如果有人使用 SHA-256 算法复制对这 100 本书进行哈希处理的过程，他们将获得与输出完全相同的哈希值。如果输出不同，我们可以确定输入已更改。这意味着无需单独或手动检查输入之间的差异，这可能是劳动密集型的。

### 2.2.加密货币世界中的 Merkle 树

当在区块链上存储交易数据时，每个新交易都是通过哈希函数提交的，哈希函数会生成唯一的哈希值。想象一下，我们有八笔交易（A 到 H），我们分别对其进行哈希处理以获得它们的哈希输出。这些就是我们所说的 Merkle 叶节点。在下图中，您可以看到每个字母的唯一哈希值：hA 代表 A，hB 代表 B，hC 代表 C，等等。

[![binance-3](https://github.com/0xchaineye/chaineye-binance-por/blob/main/images/binance-3.png)](https://github.com/0xchaineye/chaineye-binance-por/)


然后我们可以获取成对的散列输出，将它们组合起来，并接收一个新的散列输出。例如，hA 和 hB 的散列值一起散列，将为我们提供 hAB 的新散列输出，称为 Merkle 分支。请注意，每次生成新输出时，根据使用的哈希函数，它具有固定的长度和大小。

现在，我们将两个交易（例如，A 和 B）的数据组合在一个哈希（hAB）中。请注意，如果我们更改 A 或 B 的任何信息并重复该过程，我们的散列输出 hAB 将完全不同。

当我们组合新的散列对以再次对它们进行散列时，该过程将继续（见下图）。我们用 hCD 对 hAB 进行哈希处理以获得唯一的哈希 hABCD，并对 hEF 和 hGH 进行相同处理以获得 hEFGH。最后，我们收到一个散列，代表所有先前交易的散列的散列输出。换句话说，哈希输出 hABCDEFGH 代表了它之前的所有信息。

[![binance-4](https://github.com/0xchaineye/chaineye-binance-por/blob/main/images/binance-4.png)](https://github.com/0xchaineye/chaineye-binance-por/)


上面显示的图形称为 Merkle 树，散列输出 hABCDEFGH 是 Merkle 根。我们在区块头中使用 Merkle 根，因为它们以加密方式以简洁的方式总结了区块中的所有交易数据。我们还可以快速验证块内是否有任何数据被篡改或更改。


## 3.Merkle 树的局限性

让我们回到我们的 CEX 储备示例。CEX 希望证明其所有客户资产的 1:1 支持，并构建一个 Merkle 树，在代币级别将其客户 UID 与其持有的净资产（扣除资产和负债）哈希在一起。一旦发布（并签署以证明对提供的 Merkle 根的所有权），个人用户将无法在不访问其所有输入的情况下检查 Merkle 树是否有效。

交易所可能错过了一些输入。它还可以创建负余额的假账户来改变总负债。例如，虽然客户的资产总额可能为 1,000,000 美元，但可以添加一个余额为 -500,000 美元的假账户。这将创建一个仅为 500,000 美元的储备目标。

储备证明的情况不同于区块的 Merkle 根，因为用户可以在区块链浏览器上看到区块包含的所有交易。然而，出于安全和数据隐私的原因，CEX 不想披露每个账户余额。客户也不会对他们的账户余额被公开感到满意。在这种情况下，CEX 无法在不显示其他用户余额的情况下证明用户余额加起来是正确的总数。

交易所可能考虑采用的一种解决方案是使用受信任的第三方审计员。审计员可以在最终证明所提供的 Merkle 根的有效性之前检查个人账户和储备金。但是，对于用户而言，这种方法需要信任审核员以及审核所使用的数据。当您可以信任数据时，您不必依赖第三方。


## 4. 什么是 zk-SNARK

zk-SNARK （零知识简洁非交互式知识论证）是一种遵循先前概述的零知识原则的证明协议。使用 zk-SNARK，你可以证明你知道原始散列值（在下面进一步讨论）而无需透露它是什么。您还可以在不透露有关具体金额、价值或所涉及地址的任何信息的情况下证明交易的有效性。

zk-SNARKs 在区块链和加密货币世界中被广泛使用和讨论。但是你可能想知道为什么有人会在可以使用简单的公钥和私钥对方法来保护信息时使用 zk-SNARK。但是，我们无法实施数学证明来确保不包括负余额和 Merkle 树的总和。 

在交易所储备的情况下，我们想要证明客户余额的 1:1 支持，而不公开每个账户的标识符和余额。此外，zk-SNARK 技术更不可能伪造数据。


## 5. 将 zk-SNARKs 与默克尔树相结合

上述问题是使用 zk-SNARKs 的完美案例。我们想证明储备完全覆盖用户负债并且没有被伪造。但是，出于隐私和安全原因，我们不想向验证者显示用户余额和储备金的确切构成。 

通过使用 zk-SNARK，加密交易所可以证明所有 Merkle 树叶节点的余额集（即用户账户余额）对交易所声称的总用户资产余额有贡献。每个用户都可以轻松访问他们的叶节点，因为它们已包含在流程中。zk-SNARK 还确保生成的任何 Merkle 树不包含总净资产余额为负的用户（这意味着数据伪造，因为所有贷款都被超额抵押）。还使用了 Binance 全局状态的计算，即每个 Binance 客户持有的每项资产的总净余额列表。

让我们来看看币安是如何处理这种情况的。首先，币安定义了它希望证明的计算约束，并将它们定义为可编程电路。以下是币安在其模型中使用的一组三个约束。 

对于每个用户的余额集（Merkle 树叶节点），我们的电路确保：

用户的资产余额包含在 Binance 总用户净余额总和的计算中。

用户的总净余额大于或等于零。

Merkle 树根的改变是有效的（即没有使用伪造的信息）将用户的信息更新到叶节点哈希。

Binance 然后可以根据电路为 Merkle 树的构建生成 zk-SNARK 证明。这需要交易所执行散列用户 ID 和余额的大量计算，同时确保证明通过约束。

验证者将检查证明（及其公开发布的开源代码）以确信计算是在满足所有约束的情况下执行的。与证明时间相比，验证计算花费的时间极短。

在每次发布储备证明时，交易所将发布：

1. 每个用户的 Merkle 证明。

2. 所有用户的 zk-SNARK 证明和公开输入（每个资产的总净余额列表和 Merkle 根的哈希值）。

感兴趣的各方可以验证 Merkle 证明，确保他们的个人余额贡献给 Merkle 树根。他们还可以验证 zk-SNARK 证明，以确保 Merkle 树的构造满足电路中定义的约束


## 6.binance 验证过程

[![binance-2](https://github.com/0xchaineye/chaineye-binance-por/blob/main/images/binance-2.png)](https://github.com/0xchaineye/chaineye-binance-por/)




